# # CI for AWS deployments â€” build/test, build Docker images, and optionally deploy to EC2.
# # Required GitHub Secrets (placeholders):
# # - DOCKERHUB_USERNAME
# # - DOCKERHUB_TOKEN
# # - AWS_ACCESS_KEY_ID
# # - AWS_SECRET_ACCESS_KEY
# # - INPUT_HOST (optional)
# # - INPUT_USERNAME (optional)
# # - INPUT_KEY (optional, private key)
# #
# # Notes:
# # - Place deploy scripts in `backend/infrastructure/aws/` (for example `deploy_to_ec2.sh`).
# # - Migrations can be run via SSH to hosts with DB access or via separate migration runners.
# # - After deploy, test health endpoints (e.g., `GET /health`) against the public endpoint or EC2 host.

# name: CI - aws-deployment

# on:
#   push:
#     branches: [ aws-deployment ]

# jobs:
#   build-and-test:
#     name: Build and test services
#     runs-on: ubuntu-latest
#     timeout-minutes: 15
#     strategy:
#       matrix:
#         service:
#           - auth-service
#           - bff-service
#           - cart-service
#           - inventory-service
#           - order-service
#           - payment-service
#           - product-service
#           - user-service
#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Set up Go
#         uses: actions/setup-go@v5
#         with:
#           go-version: '1.25'
#           cache-dependency-path: backend/services/${{ matrix.service }}/go.sum

#       - name: Download modules
#         run: go mod download
#         working-directory: backend/services/${{ matrix.service }}

#       - name: Run tests
#         run: go test ./... -v
#         working-directory: backend/services/${{ matrix.service }}

#   docker-build-and-push:
#     name: Build and push Docker images
#     needs: build-and-test
#     runs-on: ubuntu-latest
#     timeout-minutes: 20
#     strategy:
#       matrix:
#         service:
#           - auth-service
#           - bff-service
#           - cart-service
#           - inventory-service
#           - order-service
#           - payment-service
#           - product-service
#           - user-service
#     steps:
#       - name: Checkout
#         uses: actions/checkout@v4

#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v3

#       - name: Log in to Docker Hub
#         uses: docker/login-action@v3
#         with:
#           username: "${{ secrets.DOCKERHUB_USERNAME}}"
#           password: ${{ secrets.DOCKERHUB_TOKEN }}

#       - name: Build and push image
#         uses: docker/build-push-action@v6
#         with:
#           # Use repository root as build context so service Dockerfiles
#           # can COPY files elsewhere in the repo (e.g., backend/pkg/aws).
#           context: .
#           file: ./backend/services/${{ matrix.service }}/Dockerfile
#           push: true
#           tags: |
#             ${{ secrets.DOCKERHUB_USERNAME}}/${{ matrix.service }}:latest
#             ${{ secrets.DOCKERHUB_USERNAME}}/${{ matrix.service }}:${{ github.sha }}
#           cache-from: type=gha,scope=${{ matrix.service }}
#           cache-to: type=gha,mode=max,scope=${{ matrix.service }}

#   deploy-to-ec2:
#     name: Deploy to EC2
#     needs: docker-build-and-push
#     runs-on: ubuntu-latest
#     timeout-minutes: 15
#     steps:
#       - name: Checkout Code
#         uses: actions/checkout@v4

#       # 1. Copy the script from your Repo to the EC2 Server
#       - name: Copy deploy script to EC2
#         uses: appleboy/scp-action@v0.1.7
#         with:
#           host: ${{ secrets.INPUT_HOST }}
#           username: ${{ secrets.INPUT_USERNAME }}
#           key: ${{ secrets.INPUT_KEY }}
#           source: "backend/infrastructure/aws/deploy_to_ec2.sh"
#           target: "/home/${{ secrets.INPUT_USERNAME }}"
#           strip_components: 3 # Removes 'backend/infrastructure/aws/' so it lands cleanly in HOME

#       # 2. Log in and run the script
#       - name: Deploy to EC2 via SSH
#         uses: appleboy/ssh-action@v1.0.3
#         with:
#           host: ${{ secrets.INPUT_HOST }}
#           username: ${{ secrets.INPUT_USERNAME }}
#           key: ${{ secrets.INPUT_KEY }}
#           script: |
#             set -euo pipefail
            
#             # The script is now exactly where we expect it
#             DEPLOY_SCRIPT="/home/${{ secrets.INPUT_USERNAME }}/deploy_to_ec2.sh"
            
#             echo "ğŸš€ Starting deployment script..."
#             if [ -f "${DEPLOY_SCRIPT}" ]; then
#               chmod +x "${DEPLOY_SCRIPT}"
#               bash "${DEPLOY_SCRIPT}"
#             else
#               echo "âŒ Error: Script not found at ${DEPLOY_SCRIPT}"
#               ls -la /home/${{ secrets.INPUT_USERNAME }} # Debugging: show what IS there
#               exit 1
#             fi


#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# -----------------------------
# CONFIGURATION (from env vars / CI/CD secrets)
# -----------------------------
DOCKER_HUB_USERNAME="${DOCKER_HUB_USERNAME:-yash263}"
DOCKER_HUB_PASSWORD="${DOCKER_HUB_PASSWORD:-}"
SERVICES=(auth-service bff-service cart-service inventory-service order-service payment-service product-service user-service)
COMPOSE_FILE="docker-compose.yml"
DOCKER_COMPOSE_VERSION="v2.20.2"
MAX_RETRIES=3
SLEEP_BETWEEN_RETRIES=5

# -----------------------------
# FUNCTIONS
# -----------------------------
function retry {
    local n=0
    until [ "$n" -ge "$MAX_RETRIES" ]; do
        "$@" && break
        n=$((n+1))
        echo "Command failed. Retry $n/$MAX_RETRIES..."
        sleep $SLEEP_BETWEEN_RETRIES
    done
    if [ "$n" -eq "$MAX_RETRIES" ]; then
        echo "âŒ Command failed after $MAX_RETRIES attempts: $*"
        exit 1
    fi
}

function check_file_exists {
    if [ ! -f "$1" ]; then
        echo "âŒ Required file not found: $1"
        exit 1
    fi
}

# -----------------------------
# UPDATE SYSTEM
# -----------------------------
echo "ğŸ”„ Updating system packages..."
sudo yum update -y

# -----------------------------
# INSTALL DOCKER
# -----------------------------
echo "ğŸ³ Installing Docker..."
sudo yum install -y docker
sudo systemctl enable --now docker

# -----------------------------
# CONFIGURE USER PERMISSIONS
# -----------------------------
echo "ğŸ‘¤ Adding ec2-user to docker group..."
if ! grep -q '^docker:' /etc/group; then
    sudo groupadd docker || true
fi
sudo usermod -aG docker ec2-user
newgrp docker || true

# -----------------------------
# INSTALL DOCKER COMPOSE
# -----------------------------
echo "âš™ï¸ Installing Docker Compose..."
mkdir -p ~/.docker/cli-plugins
curl -SL "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-linux-x86_64" \
     -o ~/.docker/cli-plugins/docker-compose
chmod +x ~/.docker/cli-plugins/docker-compose
docker compose version

# -----------------------------
# DOCKER LOGIN
# -----------------------------
echo "ğŸ” Logging into Docker Hub..."
echo "$DOCKER_HUB_PASSWORD" | retry docker login -u "$DOCKER_HUB_USERNAME" --password-stdin

# -----------------------------
# PULL LATEST DOCKER IMAGES
# -----------------------------
echo "â¬‡ï¸ Pulling latest images..."
for service in "${SERVICES[@]}"; do
    echo "Pulling $DOCKER_HUB_USERNAME/$service:latest..."
    retry docker pull "$DOCKER_HUB_USERNAME/$service:latest"
done

# -----------------------------
# CHECK DOCKER COMPOSE FILE
# -----------------------------
check_file_exists "$COMPOSE_FILE"

# -----------------------------
# DEPLOY SERVICES
# -----------------------------
echo "ğŸš€ Deploying services..."
docker compose down || true
docker compose up -d --remove-orphans

# -----------------------------
# HEALTH CHECKS
# -----------------------------
echo "ğŸ” Running health checks..."
for service in "${SERVICES[@]}"; do
    container_name="${service//-/_}" # Compose container names may convert '-' to '_'
    if ! docker inspect -f '{{.State.Running}}' "$container_name" &>/dev/null; then
        echo "âŒ Service $service is not running!"
    else
        echo "âœ… Service $service is running"
    fi
done

echo "ğŸ‰ Deployment complete!"
